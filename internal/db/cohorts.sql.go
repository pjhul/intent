// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: cohorts.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countCohorts = `-- name: CountCohorts :one
SELECT COUNT(*) FROM cohorts
`

func (q *Queries) CountCohorts(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countCohorts)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countCohortsByStatus = `-- name: CountCohortsByStatus :one
SELECT COUNT(*) FROM cohorts WHERE status = $1
`

func (q *Queries) CountCohortsByStatus(ctx context.Context, status string) (int64, error) {
	row := q.db.QueryRow(ctx, countCohortsByStatus, status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createCohort = `-- name: CreateCohort :one
INSERT INTO cohorts (name, description, rules, status, version)
VALUES ($1, $2, $3, $4, 1)
RETURNING id, name, description, rules, status, version, created_at, updated_at
`

type CreateCohortParams struct {
	Name        string      `json:"name"`
	Description pgtype.Text `json:"description"`
	Rules       []byte      `json:"rules"`
	Status      string      `json:"status"`
}

func (q *Queries) CreateCohort(ctx context.Context, arg CreateCohortParams) (Cohort, error) {
	row := q.db.QueryRow(ctx, createCohort,
		arg.Name,
		arg.Description,
		arg.Rules,
		arg.Status,
	)
	var i Cohort
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Rules,
		&i.Status,
		&i.Version,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteCohort = `-- name: DeleteCohort :exec
DELETE FROM cohorts
WHERE id = $1
`

func (q *Queries) DeleteCohort(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteCohort, id)
	return err
}

const getCohort = `-- name: GetCohort :one
SELECT id, name, description, rules, status, version, created_at, updated_at
FROM cohorts
WHERE id = $1
`

func (q *Queries) GetCohort(ctx context.Context, id pgtype.UUID) (Cohort, error) {
	row := q.db.QueryRow(ctx, getCohort, id)
	var i Cohort
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Rules,
		&i.Status,
		&i.Version,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCohortByName = `-- name: GetCohortByName :one
SELECT id, name, description, rules, status, version, created_at, updated_at
FROM cohorts
WHERE name = $1
`

func (q *Queries) GetCohortByName(ctx context.Context, name string) (Cohort, error) {
	row := q.db.QueryRow(ctx, getCohortByName, name)
	var i Cohort
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Rules,
		&i.Status,
		&i.Version,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCohortsUpdatedAfter = `-- name: GetCohortsUpdatedAfter :many
SELECT id, name, description, rules, status, version, created_at, updated_at
FROM cohorts
WHERE updated_at > $1
ORDER BY updated_at ASC
`

func (q *Queries) GetCohortsUpdatedAfter(ctx context.Context, updatedAt pgtype.Timestamptz) ([]Cohort, error) {
	rows, err := q.db.Query(ctx, getCohortsUpdatedAfter, updatedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Cohort{}
	for rows.Next() {
		var i Cohort
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Rules,
			&i.Status,
			&i.Version,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listActiveCohorts = `-- name: ListActiveCohorts :many
SELECT id, name, description, rules, status, version, created_at, updated_at
FROM cohorts
WHERE status = 'active'
ORDER BY created_at DESC
`

func (q *Queries) ListActiveCohorts(ctx context.Context) ([]Cohort, error) {
	rows, err := q.db.Query(ctx, listActiveCohorts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Cohort{}
	for rows.Next() {
		var i Cohort
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Rules,
			&i.Status,
			&i.Version,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCohorts = `-- name: ListCohorts :many
SELECT id, name, description, rules, status, version, created_at, updated_at
FROM cohorts
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListCohortsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListCohorts(ctx context.Context, arg ListCohortsParams) ([]Cohort, error) {
	rows, err := q.db.Query(ctx, listCohorts, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Cohort{}
	for rows.Next() {
		var i Cohort
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Rules,
			&i.Status,
			&i.Version,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCohortsByStatus = `-- name: ListCohortsByStatus :many
SELECT id, name, description, rules, status, version, created_at, updated_at
FROM cohorts
WHERE status = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListCohortsByStatusParams struct {
	Status string `json:"status"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

func (q *Queries) ListCohortsByStatus(ctx context.Context, arg ListCohortsByStatusParams) ([]Cohort, error) {
	rows, err := q.db.Query(ctx, listCohortsByStatus, arg.Status, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Cohort{}
	for rows.Next() {
		var i Cohort
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Rules,
			&i.Status,
			&i.Version,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCohort = `-- name: UpdateCohort :one
UPDATE cohorts
SET name = $2, description = $3, rules = $4, version = version + 1
WHERE id = $1
RETURNING id, name, description, rules, status, version, created_at, updated_at
`

type UpdateCohortParams struct {
	ID          pgtype.UUID `json:"id"`
	Name        string      `json:"name"`
	Description pgtype.Text `json:"description"`
	Rules       []byte      `json:"rules"`
}

func (q *Queries) UpdateCohort(ctx context.Context, arg UpdateCohortParams) (Cohort, error) {
	row := q.db.QueryRow(ctx, updateCohort,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.Rules,
	)
	var i Cohort
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Rules,
		&i.Status,
		&i.Version,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateCohortStatus = `-- name: UpdateCohortStatus :one
UPDATE cohorts
SET status = $2
WHERE id = $1
RETURNING id, name, description, rules, status, version, created_at, updated_at
`

type UpdateCohortStatusParams struct {
	ID     pgtype.UUID `json:"id"`
	Status string      `json:"status"`
}

func (q *Queries) UpdateCohortStatus(ctx context.Context, arg UpdateCohortStatusParams) (Cohort, error) {
	row := q.db.QueryRow(ctx, updateCohortStatus, arg.ID, arg.Status)
	var i Cohort
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Rules,
		&i.Status,
		&i.Version,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
