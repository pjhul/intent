// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: cohorts.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countCohorts = `-- name: CountCohorts :one
SELECT COUNT(*) FROM cohorts WHERE project_id = $1
`

func (q *Queries) CountCohorts(ctx context.Context, projectID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countCohorts, projectID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countCohortsByStatus = `-- name: CountCohortsByStatus :one
SELECT COUNT(*) FROM cohorts WHERE project_id = $1 AND status = $2
`

type CountCohortsByStatusParams struct {
	ProjectID pgtype.UUID `json:"project_id"`
	Status    string      `json:"status"`
}

func (q *Queries) CountCohortsByStatus(ctx context.Context, arg CountCohortsByStatusParams) (int64, error) {
	row := q.db.QueryRow(ctx, countCohortsByStatus, arg.ProjectID, arg.Status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createCohort = `-- name: CreateCohort :one
INSERT INTO cohorts (project_id, name, description, rules, status, version)
VALUES ($1, $2, $3, $4, $5, 1)
RETURNING id, project_id, name, description, rules, status, version, created_at, updated_at
`

type CreateCohortParams struct {
	ProjectID   pgtype.UUID `json:"project_id"`
	Name        string      `json:"name"`
	Description pgtype.Text `json:"description"`
	Rules       []byte      `json:"rules"`
	Status      string      `json:"status"`
}

type CreateCohortRow struct {
	ID          pgtype.UUID        `json:"id"`
	ProjectID   pgtype.UUID        `json:"project_id"`
	Name        string             `json:"name"`
	Description pgtype.Text        `json:"description"`
	Rules       []byte             `json:"rules"`
	Status      string             `json:"status"`
	Version     int64              `json:"version"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) CreateCohort(ctx context.Context, arg CreateCohortParams) (CreateCohortRow, error) {
	row := q.db.QueryRow(ctx, createCohort,
		arg.ProjectID,
		arg.Name,
		arg.Description,
		arg.Rules,
		arg.Status,
	)
	var i CreateCohortRow
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.Name,
		&i.Description,
		&i.Rules,
		&i.Status,
		&i.Version,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteCohort = `-- name: DeleteCohort :exec
DELETE FROM cohorts
WHERE id = $1
`

func (q *Queries) DeleteCohort(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteCohort, id)
	return err
}

const getCohort = `-- name: GetCohort :one
SELECT id, project_id, name, description, rules, status, version, created_at, updated_at
FROM cohorts
WHERE id = $1
`

type GetCohortRow struct {
	ID          pgtype.UUID        `json:"id"`
	ProjectID   pgtype.UUID        `json:"project_id"`
	Name        string             `json:"name"`
	Description pgtype.Text        `json:"description"`
	Rules       []byte             `json:"rules"`
	Status      string             `json:"status"`
	Version     int64              `json:"version"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) GetCohort(ctx context.Context, id pgtype.UUID) (GetCohortRow, error) {
	row := q.db.QueryRow(ctx, getCohort, id)
	var i GetCohortRow
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.Name,
		&i.Description,
		&i.Rules,
		&i.Status,
		&i.Version,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCohortByName = `-- name: GetCohortByName :one
SELECT id, project_id, name, description, rules, status, version, created_at, updated_at
FROM cohorts
WHERE project_id = $1 AND name = $2
`

type GetCohortByNameParams struct {
	ProjectID pgtype.UUID `json:"project_id"`
	Name      string      `json:"name"`
}

type GetCohortByNameRow struct {
	ID          pgtype.UUID        `json:"id"`
	ProjectID   pgtype.UUID        `json:"project_id"`
	Name        string             `json:"name"`
	Description pgtype.Text        `json:"description"`
	Rules       []byte             `json:"rules"`
	Status      string             `json:"status"`
	Version     int64              `json:"version"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) GetCohortByName(ctx context.Context, arg GetCohortByNameParams) (GetCohortByNameRow, error) {
	row := q.db.QueryRow(ctx, getCohortByName, arg.ProjectID, arg.Name)
	var i GetCohortByNameRow
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.Name,
		&i.Description,
		&i.Rules,
		&i.Status,
		&i.Version,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCohortsUpdatedAfter = `-- name: GetCohortsUpdatedAfter :many
SELECT id, project_id, name, description, rules, status, version, created_at, updated_at
FROM cohorts
WHERE updated_at > $1
ORDER BY updated_at ASC
`

type GetCohortsUpdatedAfterRow struct {
	ID          pgtype.UUID        `json:"id"`
	ProjectID   pgtype.UUID        `json:"project_id"`
	Name        string             `json:"name"`
	Description pgtype.Text        `json:"description"`
	Rules       []byte             `json:"rules"`
	Status      string             `json:"status"`
	Version     int64              `json:"version"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) GetCohortsUpdatedAfter(ctx context.Context, updatedAt pgtype.Timestamptz) ([]GetCohortsUpdatedAfterRow, error) {
	rows, err := q.db.Query(ctx, getCohortsUpdatedAfter, updatedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCohortsUpdatedAfterRow{}
	for rows.Next() {
		var i GetCohortsUpdatedAfterRow
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.Name,
			&i.Description,
			&i.Rules,
			&i.Status,
			&i.Version,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listActiveCohorts = `-- name: ListActiveCohorts :many
SELECT id, project_id, name, description, rules, status, version, created_at, updated_at
FROM cohorts
WHERE project_id = $1 AND status = 'active'
ORDER BY created_at DESC
`

type ListActiveCohortsRow struct {
	ID          pgtype.UUID        `json:"id"`
	ProjectID   pgtype.UUID        `json:"project_id"`
	Name        string             `json:"name"`
	Description pgtype.Text        `json:"description"`
	Rules       []byte             `json:"rules"`
	Status      string             `json:"status"`
	Version     int64              `json:"version"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) ListActiveCohorts(ctx context.Context, projectID pgtype.UUID) ([]ListActiveCohortsRow, error) {
	rows, err := q.db.Query(ctx, listActiveCohorts, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListActiveCohortsRow{}
	for rows.Next() {
		var i ListActiveCohortsRow
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.Name,
			&i.Description,
			&i.Rules,
			&i.Status,
			&i.Version,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAllActiveCohorts = `-- name: ListAllActiveCohorts :many
SELECT id, project_id, name, description, rules, status, version, created_at, updated_at
FROM cohorts
WHERE status = 'active'
ORDER BY created_at DESC
`

type ListAllActiveCohortsRow struct {
	ID          pgtype.UUID        `json:"id"`
	ProjectID   pgtype.UUID        `json:"project_id"`
	Name        string             `json:"name"`
	Description pgtype.Text        `json:"description"`
	Rules       []byte             `json:"rules"`
	Status      string             `json:"status"`
	Version     int64              `json:"version"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) ListAllActiveCohorts(ctx context.Context) ([]ListAllActiveCohortsRow, error) {
	rows, err := q.db.Query(ctx, listAllActiveCohorts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListAllActiveCohortsRow{}
	for rows.Next() {
		var i ListAllActiveCohortsRow
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.Name,
			&i.Description,
			&i.Rules,
			&i.Status,
			&i.Version,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCohorts = `-- name: ListCohorts :many
SELECT id, project_id, name, description, rules, status, version, created_at, updated_at
FROM cohorts
WHERE project_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListCohortsParams struct {
	ProjectID pgtype.UUID `json:"project_id"`
	Limit     int32       `json:"limit"`
	Offset    int32       `json:"offset"`
}

type ListCohortsRow struct {
	ID          pgtype.UUID        `json:"id"`
	ProjectID   pgtype.UUID        `json:"project_id"`
	Name        string             `json:"name"`
	Description pgtype.Text        `json:"description"`
	Rules       []byte             `json:"rules"`
	Status      string             `json:"status"`
	Version     int64              `json:"version"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) ListCohorts(ctx context.Context, arg ListCohortsParams) ([]ListCohortsRow, error) {
	rows, err := q.db.Query(ctx, listCohorts, arg.ProjectID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListCohortsRow{}
	for rows.Next() {
		var i ListCohortsRow
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.Name,
			&i.Description,
			&i.Rules,
			&i.Status,
			&i.Version,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCohortsByStatus = `-- name: ListCohortsByStatus :many
SELECT id, project_id, name, description, rules, status, version, created_at, updated_at
FROM cohorts
WHERE project_id = $1 AND status = $2
ORDER BY created_at DESC
LIMIT $3 OFFSET $4
`

type ListCohortsByStatusParams struct {
	ProjectID pgtype.UUID `json:"project_id"`
	Status    string      `json:"status"`
	Limit     int32       `json:"limit"`
	Offset    int32       `json:"offset"`
}

type ListCohortsByStatusRow struct {
	ID          pgtype.UUID        `json:"id"`
	ProjectID   pgtype.UUID        `json:"project_id"`
	Name        string             `json:"name"`
	Description pgtype.Text        `json:"description"`
	Rules       []byte             `json:"rules"`
	Status      string             `json:"status"`
	Version     int64              `json:"version"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) ListCohortsByStatus(ctx context.Context, arg ListCohortsByStatusParams) ([]ListCohortsByStatusRow, error) {
	rows, err := q.db.Query(ctx, listCohortsByStatus,
		arg.ProjectID,
		arg.Status,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListCohortsByStatusRow{}
	for rows.Next() {
		var i ListCohortsByStatusRow
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.Name,
			&i.Description,
			&i.Rules,
			&i.Status,
			&i.Version,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCohort = `-- name: UpdateCohort :one
UPDATE cohorts
SET name = $2, description = $3, rules = $4, version = version + 1
WHERE id = $1
RETURNING id, project_id, name, description, rules, status, version, created_at, updated_at
`

type UpdateCohortParams struct {
	ID          pgtype.UUID `json:"id"`
	Name        string      `json:"name"`
	Description pgtype.Text `json:"description"`
	Rules       []byte      `json:"rules"`
}

type UpdateCohortRow struct {
	ID          pgtype.UUID        `json:"id"`
	ProjectID   pgtype.UUID        `json:"project_id"`
	Name        string             `json:"name"`
	Description pgtype.Text        `json:"description"`
	Rules       []byte             `json:"rules"`
	Status      string             `json:"status"`
	Version     int64              `json:"version"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) UpdateCohort(ctx context.Context, arg UpdateCohortParams) (UpdateCohortRow, error) {
	row := q.db.QueryRow(ctx, updateCohort,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.Rules,
	)
	var i UpdateCohortRow
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.Name,
		&i.Description,
		&i.Rules,
		&i.Status,
		&i.Version,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateCohortStatus = `-- name: UpdateCohortStatus :one
UPDATE cohorts
SET status = $2
WHERE id = $1
RETURNING id, project_id, name, description, rules, status, version, created_at, updated_at
`

type UpdateCohortStatusParams struct {
	ID     pgtype.UUID `json:"id"`
	Status string      `json:"status"`
}

type UpdateCohortStatusRow struct {
	ID          pgtype.UUID        `json:"id"`
	ProjectID   pgtype.UUID        `json:"project_id"`
	Name        string             `json:"name"`
	Description pgtype.Text        `json:"description"`
	Rules       []byte             `json:"rules"`
	Status      string             `json:"status"`
	Version     int64              `json:"version"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) UpdateCohortStatus(ctx context.Context, arg UpdateCohortStatusParams) (UpdateCohortStatusRow, error) {
	row := q.db.QueryRow(ctx, updateCohortStatus, arg.ID, arg.Status)
	var i UpdateCohortStatusRow
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.Name,
		&i.Description,
		&i.Rules,
		&i.Status,
		&i.Version,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
